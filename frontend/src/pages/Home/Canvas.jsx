// src/pages/Home/Canvas.jsx
import React, { useEffect, useRef, useCallback, useState } from "react";
import {
  Card,
  Button,
  Spin,
  Alert,
  Modal,
  Radio,
  Tag,
  message,
  theme,
} from "antd";
import { SettingOutlined } from "@ant-design/icons";
import { useMutation, useQuery } from "@tanstack/react-query";
import { useAtomValue, useAtom } from "jotai";
import { mapsQueryAtom, robotsQueryAtom, selectedMapAtom } from "@/state/atoms";
import arrowIcon from "@/assets/arrow.png";
import SignalOverlay from "@/components/SignalOverlay";
import PasswordConfirm from "@/components/PasswordConfirm";
import usePasswordConfirm from "@/hooks/usePasswordConfirm";

// ÏïàÏ†ÑÌïú JSON ÌååÏã±
function safeParse(raw, fallback = {}) {
  if (raw == null) return fallback;
  let v = raw;
  try {
    if (typeof v === "string") v = JSON.parse(v);
    if (typeof v === "string") v = JSON.parse(v);
  } catch {
    return fallback;
  }
  return v ?? fallback;
}

const CORE = import.meta.env.VITE_CORE_BASE_URL;
const ICON_MM = { width: 800, height: 1200 };

export default function Canvas() {
  // jotai
  const mapsQ = useAtomValue(mapsQueryAtom);
  const robotsQ = useAtomValue(robotsQueryAtom);
  const [selMap, setSelMap] = useAtom(selectedMapAtom);

  const maps = mapsQ.data ?? [];
  const robots = robotsQ.data ?? [];

  const { token } = theme.useToken();

  // Ìå®Ïä§ÏõåÎìú Ïª®Ìéå ÌõÖ Ï∂îÍ∞Ä
  const passwordConfirm = usePasswordConfirm();

  // station tooltip state
  const [hoveredStationClasses, setHoveredStationClasses] = useState(null);
  const [stationTooltipPos, setStationTooltipPos] = useState({ x: 0, y: 0 });

  // ÌéÑÏä§ Ïï†ÎãàÎ©îÏù¥ÏÖòÏùÑ ÏúÑÌïú ÏÉÅÌÉú
  const [pulseTime, setPulseTime] = useState(0);

  // localStorageÏóêÏÑú Ï†ÄÏû•Îêú Î∑∞ ÏÉÅÌÉú Î≥µÏõê Ìï®Ïàò
  const getStoredViewState = useCallback(() => {
    try {
      const stored = localStorage.getItem('canvas-view-state');
      if (stored) {
        const parsed = JSON.parse(stored);
        return {
          scale: parsed.scale || 1.5, // Í∏∞Î≥∏Í∞íÏùÑ 1.5Î°ú Î≥ÄÍ≤Ω
          offset: parsed.offset || { x: 100, y: 100 } // Í∏∞Î≥∏ Ïò§ÌîÑÏÖã Î≥ÄÍ≤Ω
        };
      }
    } catch (error) {
      console.warn('Failed to parse stored view state:', error);
    }
    return {
      scale: 1.5, // Í∏∞Î≥∏ Ïä§ÏºÄÏùº Í∞í
      offset: { x: 100, y: 100 } // Í∏∞Î≥∏ Ïò§ÌîÑÏÖã Í∞í
    };
  }, []);

  // localStorageÏóê Î∑∞ ÏÉÅÌÉú Ï†ÄÏû• Ìï®Ïàò
  const saveViewState = useCallback((scale, offset) => {
    try {
      localStorage.setItem('canvas-view-state', JSON.stringify({
        scale,
        offset
      }));
    } catch (error) {
      console.warn('Failed to save view state:', error);
    }
  }, []);

  // AMR ÏÉÅÌÉú ÌåêÎã® Ìï®Ïàò (AMRStatus.jsxÏôÄ ÎèôÏùºÌïú Î°úÏßÅ)
  const getAmrStatus = useCallback((amr) => {
    // Ïó∞Í≤∞ ÎÅäÍπÄ ÏÉÅÌÉúÎ•º ÏµúÏö∞ÏÑ†ÏúºÎ°ú ÌôïÏù∏
    if (amr.status === 'Ïó∞Í≤∞ ÎÅäÍπÄ') {
      return 'Ïó∞Í≤∞ ÎÅäÍπÄ';
    }
    
    let additionalInfo = {};
    try {
      additionalInfo = typeof amr.additional_info === 'string' 
        ? JSON.parse(amr.additional_info) 
        : amr.additional_info || {};
    } catch (e) {
      // JSON ÌååÏã± Ïã§Ìå® Ïãú Îπà Í∞ùÏ≤¥ ÏÇ¨Ïö©
    }
    
    // DI ÏÑºÏÑú 11Î≤àÏù¥ trueÏù¥Î©¥ 'ÏàòÎèô' ÏÉÅÌÉúÎ°ú ÌëúÏãú
    const diSensors = additionalInfo.diSensors || [];
    const sensor11 = diSensors.find(s => s.id === 11);
    if (sensor11?.status === true) {
      return 'ÏàòÎèô';
    }
    
    // chargingÏù¥ trueÏù¥Î©¥ 'Ï∂©Ï†Ñ' ÏÉÅÌÉúÎ°ú ÌëúÏãú
    if (additionalInfo.charging === true) {
      return 'Ï∂©Ï†Ñ';
    }
    
    // Í∏∞Ï°¥ ÏÉÅÌÉú Î∞òÌôò
    return amr.status || 'unknown';
  }, []);

  // Í∞Å Î°úÎ¥áÏùò ÌòÑÏû¨ task ÏÉÅÌÉúÎ•º Ï°∞ÌöåÌïòÎäî ÏøºÎ¶¨
  const robotTasksQuery = useQuery({
    queryKey: ["robotTasks", robots.map(r => r.id)],
    queryFn: async () => {
      if (robots.length === 0) return {};
      
      const taskPromises = robots.map(async (robot) => {
        try {
          const response = await fetch(`${CORE}/api/robots/${robot.id}/current-task`);
          if (response.status === 404) {
            return { robotId: robot.id, task: null };
          }
          if (!response.ok) {
            throw new Error(`Failed to fetch task for robot ${robot.id}`);
          }
          const task = await response.json();
          return { robotId: robot.id, task };
        } catch (error) {
          console.warn(`Failed to fetch task for robot ${robot.id}:`, error);
          return { robotId: robot.id, task: null };
        }
      });

      const results = await Promise.all(taskPromises);
      const taskMap = {};
      results.forEach(({ robotId, task }) => {
        taskMap[robotId] = task;
      });
      return taskMap;
    },
    refetchInterval: 5000,
    enabled: robots.length > 0,
    staleTime: 5000,
  });

  const robotTasks = robotTasksQuery.data || {};

  // ÌéÑÏä§ Ìö®Í≥º ÏÉâÏÉÅÍ≥º Ï°∞Í±¥ Í≤∞Ï†ï
  const getPulseEffect = useCallback((robot) => {
    const status = getAmrStatus(robot);
    const currentTask = robotTasks[robot.id];
    
    // Ïó∞Í≤∞ ÎÅäÍπÄ ÏÉÅÌÉú - Îπ®Í∞ÑÏÉâ (ÏµúÏö∞ÏÑ†)
    if (status === 'Ïó∞Í≤∞ ÎÅäÍπÄ') {
      return { color: '#ff4d4f', shouldPulse: true };
    }
    
    // Ïò§Î•ò ÏÉÅÌÉúÏù¥Í±∞ÎÇò ÏùºÏãúÏ†ïÏßÄÎêú taskÍ∞Ä ÏûàÎäî Í≤ΩÏö∞ - Îπ®Í∞ÑÏÉâ
    if (status === 'Ïò§Î•ò' || (currentTask && currentTask.paused)) {
      return { color: '#ff4d4f', shouldPulse: true };
    }
    
    // Ï∂©Ï†Ñ ÏÉÅÌÉú - ÎÖ∏ÎûÄÏÉâ
    if (status === 'Ï∂©Ï†Ñ') {
      return { color: '#faad14', shouldPulse: true };
    }
    
    // Ïù¥Îèô ÏÉÅÌÉú - Î∏åÎûúÎìú Ïª¨Îü¨
    if (status === 'Ïù¥Îèô') {
      return { color: token.colorPrimary, shouldPulse: true };
    }
    
    return { shouldPulse: false };
  }, [getAmrStatus, robotTasks, token.colorPrimary]);

  // ÌéÑÏä§ Ïï†ÎãàÎ©îÏù¥ÏÖòÏùÑ 30fpsÎ°ú Ï†úÌïú
  useEffect(() => {
    let animationId;
    let lastTime = 0;
    const targetFPS = 30; // 60fps -> 30fpsÎ°ú Í∞êÏÜå
    const frameInterval = 1000 / targetFPS;
    
    const animate = (currentTime) => {
      if (currentTime - lastTime >= frameInterval) {
        setPulseTime(currentTime);
        lastTime = currentTime;
      }
      animationId = requestAnimationFrame(animate);
    };
    animate(0);
    return () => cancelAnimationFrame(animationId);
  }, []);

  // ÏßÄÎèÑ Î≥ÄÍ≤Ω API
  const saveCurrent = useMutation({
    mutationFn: (id) =>
      fetch(`${CORE}/api/maps/current`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ mapId: id }),
      }),
  });

  // Î™®Îã¨ ÏÉÅÌÉú
  const [modalOpen, setModalOpen] = useState(false);
  const [tempId, setTempId] = useState(selMap?.id);

  // Ï∫îÎ≤ÑÏä§ refs
  const contRef = useRef(null);
  const canvRef = useRef(null);

  // Î∑∞ ÏÉÅÌÉú (localStorageÏóêÏÑú Ï¥àÍ∏∞Í∞í Î≥µÏõê)
  const initialViewState = getStoredViewState();
  const [scale, setScale] = useState(initialViewState.scale);
  const [offset, setOffset] = useState(initialViewState.offset);
  const [sf, setSf] = useState(1);

  // Ïä§ÏºÄÏùºÍ≥º Ïò§ÌîÑÏÖãÏù¥ Î≥ÄÍ≤ΩÎê† ÎïåÎßàÎã§ localStorageÏóê Ï†ÄÏû•
  useEffect(() => {
    saveViewState(scale, offset);
  }, [scale, offset, saveViewState]);

  // station Ïõê Î∞òÏßÄÎ¶Ñ
  const rPix = ((ICON_MM.width / 1000) * sf * scale) / 6;

  // Î°úÎ¥á ÏïÑÏù¥ÏΩò Î°úÎìú
  const [robotImg, setRobotImg] = useState(null);
  useEffect(() => {
    const img = new Image();
    img.src = arrowIcon;
    img.onload = () => setRobotImg(img);
    img.onerror = () => console.error("üö® arrow.png Î°úÎìú Ïã§Ìå®:", arrowIcon);
  }, []);

  // DPI ÎåÄÏùë
  const fitCanvas = useCallback(() => {
    if (!contRef.current || !canvRef.current) return;
    const rect = contRef.current.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    const c = canvRef.current;
    c.width = rect.width * dpr;
    c.height = rect.height * dpr;
    c.style.width = `${rect.width}px`;
    c.style.height = `${rect.height}px`;
    c.getContext("2d").setTransform(dpr, 0, 0, dpr, 0, 0);
  }, []);
  useEffect(() => {
    fitCanvas();
    window.addEventListener("resize", fitCanvas);
    return () => window.removeEventListener("resize", fitCanvas);
  }, [fitCanvas]);

  // ÏßÄÎèÑ Î≥ÄÍ≤Ω Ïãú Î∑∞ Ï¥àÍ∏∞Ìôî (Ï†ÄÏû•Îêú Í∞íÏù¥ ÏûàÏúºÎ©¥ ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ Í≥ÑÏÇ∞Îêú Í∞í ÏÇ¨Ïö©)
  useEffect(() => {
    if (!contRef.current || !selMap) return;
    const hdr = safeParse(selMap.additional_info).header || {};
    const { minPos, maxPos, resolution } = hdr;
    if (!minPos || !maxPos) return;
    
    const nSf = resolution ? 1 / resolution : 1;
    setSf(nSf);
    
    // localStorageÏóê Ï†ÄÏû•Îêú Í∞íÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
    const storedState = getStoredViewState();
    
    // Ï†ÄÏû•Îêú Í∞íÏù¥ Í∏∞Î≥∏Í∞íÏù¥ ÏïÑÎãàÎùºÎ©¥ (Ï¶â, ÏÇ¨Ïö©ÏûêÍ∞Ä Ï°∞Ï†ïÌïú Í∞íÏù¥ÎùºÎ©¥) Í∑∏ÎåÄÎ°ú ÏÇ¨Ïö©
    if (storedState.scale !== 1.5 || storedState.offset.x !== 100 || storedState.offset.y !== 100) {
      setScale(storedState.scale);
      setOffset(storedState.offset);
    } else {
      // Ï†ÄÏû•Îêú Í∞íÏù¥ ÏóÜÍ±∞ÎÇò Í∏∞Î≥∏Í∞íÏù¥ÎùºÎ©¥ ÏßÄÎèÑ Ï§ëÏïôÏúºÎ°ú Ï¥àÍ∏∞Ìôî
      const midX = (minPos.x + maxPos.x) / 2;
      const midY = (minPos.y + maxPos.y) / 2;
      const rect = contRef.current.getBoundingClientRect();
      setScale(1.5); // Í∏∞Î≥∏ Ïä§ÏºÄÏùº Ï†ÅÏö©
      setOffset({
        x: rect.width / 2 - midX * nSf,
        y: rect.height / 2 - midY * nSf,
      });
    }
  }, [selMap, getStoredViewState]);

  // Ï¢åÌëú Î≥ÄÌôò
  const transform = (x, y) => {
    const h = contRef.current?.getBoundingClientRect().height || 0;
    return {
      x: x * sf * scale + offset.x,
      y: h - (y * sf * scale + offset.y),
    };
  };

  // Í∑∏Î¶¨Í∏∞
  const draw = () => {
    const c = canvRef.current;
    if (!c || !selMap) return;
    const ctx = c.getContext("2d");
    ctx.clearRect(0, 0, c.width, c.height);

    // normalPointList Í∑∏Î¶¨Í∏∞ (Î∞∞Ïπò Î†åÎçîÎßÅ)
    const normalPoints =
      safeParse(selMap.additional_info).normalPointList ?? [];
    if (normalPoints.length > 0) {
      ctx.fillStyle = token.colorInfo;
      ctx.beginPath();
      normalPoints.forEach((pt) => {
        const { x, y } = transform(pt.x, pt.y);
        ctx.moveTo(x + 2, y);
        ctx.arc(x, y, 2, 0, Math.PI * 2);
      });
      ctx.fill();
    }

    // Í∏∞Ï°¥ normals(legacy) Í∑∏Î¶¨Í∏∞
    const normals = safeParse(selMap.additional_info).normalPosList ?? [];
    if (normals.length > 0) {
      ctx.fillStyle = "#000";
      normals.forEach((pt) => {
        const q = transform(pt.x, pt.y);
        ctx.fillRect(q.x, q.y, 1, 1);
      });
    }

    // Í≤ΩÎ°ú Í∑∏Î¶¨Í∏∞ (Î∞∞Ïπò Î†åÎçîÎßÅ)
    const paths = safeParse(selMap.paths).paths ?? [];
    const stations = safeParse(selMap.stations).stations ?? [];
    if (paths.length > 0) {
      ctx.strokeStyle = "#f00";
      ctx.beginPath();
      paths.forEach((p) => {
        let s = p.coordinates?.start;
        let e = p.coordinates?.end;
        if (!s || !e) {
          s = stations.find((st) => String(st.id) === String(p.start));
          e = stations.find((st) => String(st.id) === String(p.end));
        }
        if (!s || !e) return;
        const sp = transform(s.x, s.y);
        const ep = transform(e.x, e.y);
        ctx.moveTo(sp.x, sp.y);
        ctx.lineTo(ep.x, ep.y);
      });
      ctx.stroke();
    }

    // Stations Í∑∏Î¶¨Í∏∞ (Î∞∞Ïπò Î†åÎçîÎßÅ)
    if (stations.length > 0) {
      ctx.fillStyle = "#ffa500";
      ctx.font = `${12 * scale}px sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      
      // Î™®Îì† Ïä§ÌÖåÏù¥ÏÖò ÏõêÏùÑ ÌïúÎ≤àÏóê Í∑∏Î¶¨Í∏∞
      ctx.beginPath();
      stations.forEach((st) => {
        const p = transform(st.x, st.y);
        ctx.moveTo(p.x + rPix, p.y);
        ctx.arc(p.x, p.y, rPix, 0, Math.PI * 2);
      });
      ctx.fill();
      
      // ÌÖçÏä§Ìä∏Îäî Î≥ÑÎèÑÎ°ú Í∑∏Î¶¨Í∏∞
      ctx.fillStyle = "#333";
      stations.forEach((st) => {
        const p = transform(st.x, st.y);
        ctx.fillText(st.name || st.id, p.x, p.y + rPix + 2);
      });
    }

    // Robots Í∑∏Î¶¨Í∏∞
    if (robotImg) {
      robots.forEach((r) => {
        const pos = safeParse(r.position, {
          x: 0,
          y: 0,
          angle: 0,
        });
        const p = transform(pos.x, pos.y);
        const sizePx = (ICON_MM.width / 1000) * sf * scale;
        
        // ÌéÑÏä§ Ìö®Í≥º Í∑∏Î¶¨Í∏∞
        const pulseEffect = getPulseEffect(r);
        if (pulseEffect.shouldPulse) {
          const pulsePhase = (pulseTime % 2000) / 2000; // 2Ï¥à Ï£ºÍ∏∞
          const pulseRadius = sizePx * 0.8 * (1 + Math.sin(pulsePhase * Math.PI * 2) * 0.3);
          const pulseOpacity = 0.6 * (1 - pulsePhase);
          
          // ÌéÑÏä§ Ïõê Í∑∏Î¶¨Í∏∞
          ctx.save();
          ctx.globalAlpha = pulseOpacity;
          ctx.strokeStyle = pulseEffect.color;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(p.x, p.y, pulseRadius, 0, Math.PI * 2);
          ctx.stroke();
          
          // Ï∂îÍ∞Ä ÌéÑÏä§ ÎßÅ (Îçî ÌÅ∞ Ïõê)
          const outerPulseRadius = sizePx * 1.2 * (1 + Math.sin(pulsePhase * Math.PI * 2 + Math.PI) * 0.4);
          const outerPulseOpacity = 0.3 * (1 - pulsePhase);
          ctx.globalAlpha = outerPulseOpacity;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(p.x, p.y, outerPulseRadius, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }
        
        // Î°úÎ¥á Ïù¥ÎØ∏ÏßÄ Í∑∏Î¶¨Í∏∞
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(-pos.angle + Math.PI / 2);
        ctx.drawImage(robotImg, -sizePx / 2, -sizePx / 2, sizePx, sizePx);
        ctx.restore();
      });
    }
  };
  useEffect(draw, [
    selMap,
    scale,
    offset,
    sf,
    robots,
    robotImg,
    token.colorInfo,
    pulseTime,
    getPulseEffect,
    robotTasks,
  ]);

  // Ìå®Îãù & Ï§å
  const [drag, setDrag] = useState(false);
  const [last, setLast] = useState({ x: 0, y: 0 });

  const getPos = (e) => {
    const r = canvRef.current.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top };
  };
  const onDown = (e) => {
    if (e.button !== 0) return;
    setDrag(true);
    setLast(getPos(e));
  };
  const onMove = (e) => {
    if (drag) {
      const p = getPos(e);
      setOffset((o) => ({
        x: o.x + p.x - last.x,
        y: o.y - p.y + last.y,
      }));
      setLast(p);
    }
    handleHover(e);
    handleStationHover(e);
  };
  const onUp = () => setDrag(false);

  const onWheel = (e) => {
    e.preventDefault();
    const p = getPos(e);
    const fac = e.deltaY < 0 ? 1.1 : 1 / 1.1;
    const ns = Math.max(0.1, Math.min(scale * fac, 80));
    const ratio = ns / scale;
    const rect = contRef.current.getBoundingClientRect();
    setScale(ns);
    setOffset((o) => ({
      x: o.x * ratio + p.x * (1 - ratio),
      y: o.y * ratio + (rect.height - p.y) * (1 - ratio),
    }));
  };

  // Î°úÎ¥á Ìà¥ÌåÅ ÏÉÅÌÉú
  const [hoveredRobotName, setHoveredRobotName] = useState(null);
  const [tooltipPos, setTooltipPos] = useState({ x: 0, y: 0 });

  const handleHover = (e) => {
    const pos = getPos(e);
    let found = null;
    robots.forEach((r) => {
      const rp = safeParse(r.position, {
        x: 0,
        y: 0,
        angle: 0,
      });
      const pScr = transform(rp.x, rp.y);
      const dx = pScr.x - pos.x;
      const dy = pScr.y - pos.y;
      if (dx * dx + dy * dy <= (rPix + 5) ** 2) {
        found = r;
      }
    });
    if (found) {
      setHoveredRobotName(found.name);
      setTooltipPos({ x: e.clientX, y: e.clientY });
    } else {
      setHoveredRobotName(null);
    }
  };

  const handleStationHover = (e) => {
    const pos = getPos(e);
    // re-parse the stations here
    const stations = safeParse(selMap?.stations).stations ?? [];
    let found = null;
    stations.forEach((st) => {
      const p = transform(st.x, st.y);
      const dx = p.x - pos.x,
        dy = p.y - pos.y;
      if (dx * dx + dy * dy <= rPix * rPix) {
        found = st;
        console.log(st);
      }
    });
    if (found) {
      const classes = Array.isArray(found.class)
        ? found.class
        : Array.isArray(found.classList)
        ? found.classList
        : found.class
        ? [found.class]
        : [];
      setHoveredStationClasses(classes);
      console.log(classes);
      setStationTooltipPos({ x: e.clientX, y: e.clientY });
    } else {
      setHoveredStationClasses(null);
    }
  };

  // Ïö∞ÌÅ¥Î¶≠ Î©îÎâ¥ ÏÉÅÌÉú
  const [menuVisible, setMenuVisible] = useState(false);
  const [menuPos, setMenuPos] = useState({ x: 0, y: 0 });
  const [menuStation, setMenuStation] = useState(null);

  const onCanvasContextMenu = (e) => {
    e.preventDefault();
    if (!selMap) return;
    const stations = safeParse(selMap.stations).stations ?? [];
    const click = getPos(e);
    const clicked = stations.find((st) => {
      const p = transform(st.x, st.y);
      const dx = p.x - click.x,
        dy = p.y - click.y;
      return dx * dx + dy * dy <= rPix * rPix;
    });
    if (clicked) {
      setMenuStation(clicked);
      setMenuPos({ x: e.clientX, y: e.clientY });
      setMenuVisible(true);
    }
  };

  // Ìå®Ïä§ÏõåÎìú ÌôïÏù∏ ÌõÑ Î°úÎ¥á Ïù¥Îèô Î™ÖÎ†π Ïã§Ìñâ
  const dispatchRobot = async (robotId) => {
    if (!menuStation) return;
    
    const robotName = robots.find(r => r.id === robotId)?.name || robotId;
    const stationName = menuStation.name ?? menuStation.id;
    
    // Ìå®Ïä§ÏõåÎìú ÌôïÏù∏ ÏöîÏ≤≠
    passwordConfirm.showPasswordConfirm(
      async () => {
        try {
          await fetch(`${CORE}/api/robots/${robotId}/move`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              station: stationName,
            }),
          });
          message.success(`Î°úÎ¥á ${robotName} ‚Üí ${stationName} Ïù¥Îèô Î™ÖÎ†π Î≥¥ÎÉÑ`);
        } catch {
          message.error("Ïù¥Îèô Î™ÖÎ†π Ïã§Ìå®");
        }
      },
      {
        title: "Î°úÎ¥á Ïù¥Îèô Î™ÖÎ†π ÌôïÏù∏",
        description: `Î°úÎ¥á ${robotName}ÏùÑ(Î•º) ${stationName}ÏúºÎ°ú Ïù¥ÎèôÏãúÌÇ§ÏãúÍ≤†ÏäµÎãàÍπå?`
      }
    );
    
    // Î©îÎâ¥ Îã´Í∏∞
    setMenuVisible(false);
  };

  return (
    <>
      <Card
        size="small"
        title={`${selMap?.name ?? "‚Äï"}`}
        extra={
          <Button
            size="small"
            icon={<SettingOutlined />}
            onClick={() => {
              setTempId(selMap?.id);
              setModalOpen(true);
            }}
          />
        }
        style={{ height: "calc(100%)" }}
        bodyStyle={{ height: "calc(100%)" }}
      >
        <div
          ref={contRef}
          style={{
            position: "relative",
            width: "100%",
            height: "calc(100% - 40px)",
            backgroundColor: token.colorBgContainer,
            boxShadow: "inset 0 2px 8px rgba(0,0,0,0.1)",
            borderRadius: token.borderRadius,
            overflow: "hidden",
            padding: token.padding,
            boxSizing: "border-box",
          }}
        >
          <SignalOverlay />

          <canvas
            ref={canvRef}
            style={{
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              height: "100%",
              cursor: drag ? "grabbing" : "grab",
            }}
            onMouseDown={onDown}
            onMouseMove={onMove}
            onMouseUp={onUp}
            onMouseLeave={onUp}
            onWheel={onWheel}
            onContextMenu={onCanvasContextMenu}
          />

          {menuVisible && menuStation && (
            <div
              style={{
                position: "fixed",
                top: menuPos.y,
                left: menuPos.x,
                background: "#fff",
                border: "1px solid rgba(0,0,0,0.15)",
                boxShadow: "0 2px 8px rgba(0,0,0,0.15)",
                zIndex: 1000,
              }}
              onMouseLeave={() => setMenuVisible(false)}
            >
              {robots.map((r) => (
                <div
                  key={r.id}
                  style={{ padding: "4px 12px", cursor: "pointer" }}
                  onClick={() => dispatchRobot(r.id)}
                >
                  {r.name}
                </div>
              ))}
            </div>
          )}

          {hoveredRobotName && (
            <div
              style={{
                position: "fixed",
                top: tooltipPos.y + 10,
                left: tooltipPos.x + 10,
                background: "rgba(0,0,0,0.75)",
                color: "#fff",
                padding: "4px 8px",
                borderRadius: 4,
                pointerEvents: "none",
                whiteSpace: "nowrap",
                fontSize: 12,
              }}
            >
              {hoveredRobotName}
            </div>
          )}
          {hoveredStationClasses && (
            <div
              style={{
                position: "fixed",
                top: stationTooltipPos.y + 10,
                left: stationTooltipPos.x + 10,
                background: "rgba(0,0,0,0.75)",
                color: "#fff",
                padding: "4px 8px",
                borderRadius: 4,
                pointerEvents: "none",
                whiteSpace: "nowrap",
                fontSize: 12,
              }}
            >
              {hoveredStationClasses.join(", ")}
            </div>
          )}
        </div>
      </Card>

      {/* Îßµ ÏÑ†ÌÉù Î™®Îã¨ */}
      <Modal
        title="Îßµ ÏÑ†ÌÉù"
        open={modalOpen}
        okText="ÏÑ†ÌÉù"
        cancelText="Ï∑®ÏÜå"
        onOk={() => {
          const m = maps.find((x) => x.id === tempId);
          if (m) {
            setSelMap(m);
            saveCurrent.mutate(m.id);
          }
          setModalOpen(false);
        }}
        onCancel={() => setModalOpen(false)}
      >
        {mapsQ.isLoading && maps.length === 0 ? (
          <Spin />
        ) : mapsQ.error ? (
          <Alert type="error" message="Îßµ Î°úÎìú Ïã§Ìå®" />
        ) : (
          <Radio.Group
            value={tempId}
            onChange={(e) => setTempId(e.target.value)}
            style={{ display: "flex", flexDirection: "column", gap: 8 }}
          >
            {maps.map((m) => (
              <Radio key={m.id} value={m.id}>
                {m.name}{" "}
                {m.is_current && (
                  <Tag color="blue" style={{ marginLeft: 4 }}>
                    ÌòÑÏû¨
                  </Tag>
                )}
              </Radio>
            ))}
          </Radio.Group>
        )}
      </Modal>

      {/* Ìå®Ïä§ÏõåÎìú ÌôïÏù∏ Î™®Îã¨ */}
      <PasswordConfirm
        visible={passwordConfirm.isVisible}
        onConfirm={passwordConfirm.handleConfirm}
        onCancel={passwordConfirm.handleCancel}
        {...passwordConfirm.modalProps}
      />
    </>
  );
}
